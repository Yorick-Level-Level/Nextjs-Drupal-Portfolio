# Extending Interfaces

When extending the schema using the `*.extension.graphqls` files, it's important to note that adding a field to an interface does not automatically add it to all types that implement the interface. For example, if you want to add a field to the `Node` interface and have it available in all types implementing it (e.g., `NodePage`, `NodeArticle`, etc.), you need to extend each type individually.

Extending the `Node` interface alone without extending the implementing types will result in an invalid schema. To resolve this, you can extend the interface and add the field to each implementing type separately. Here's an example:

```graphql
extend interface Node {
  myCustomField: String
}

extend type NodePage {
  myCustomField: String
}

extend type NodeArticle {
  myCustomField: String
}

extend type NodeTopic {
  myCustomField: String
}
```

While this approach works for a small number of types, it becomes cumbersome and hard to maintain as the number of types grows. To address this issue, there are two recommended solutions:

## Using a computed field

Defining a custom computed field on the entity type is a clean and effective solution. This approach allows the field to be available both in GraphQL and outside of it. You can refer to the [Dynamic/Virtual field values using computed field property classes](https://www.drupal.org/docs/drupal-apis/entity-api/dynamicvirtual-field-values-using-computed-field-property-classes) tutorial for guidance on creating a computed field. After creating the computed field, you need to enable it in the schema configuration. Detailed instructions for enabling fields can be found in the [configuration documentation](/basics/configuration.html#enabling-fields).

## Using the `getInterfaceExtender` method

The `getInterfaceExtender` method provides a solution when you want to extend an interface that doesn't map to an entity type in Drupal. To implement this solution, follow these steps:

1. Implement the `getInterfaceExtender` method from the `CoreSchemaInterfaceExtensionInterface` interface in your schema extension.
2. The module's schema builder will call this method before generating the interfaces and will add the fields to the interface.
3. In the `getInterfaceExtender` method, specify the interface you want to extend and define the fields to be added.
4. Use the `EntitySchemaBuilder` instance provided as an argument to access the already generated types.
5. Make sure to wrap access to the `getType()` method in a closure to handle cases where the type may not exist at that point.

Here's an example implementation:

```php
public function getInterfaceExtender() {
  return [
    'Node' => [
      function (EntitySchemaBuilder $schemaBuilder, array &$fields) {
        $fields['myCustomField'] = [
          'type' => Type::string(),
          'description' => 'This is just my little custom field.',
        ];
      },
    ],
  ];
}
```

Now, when the types for all node bundles are generated, they will inherit the fields from the `Node` interface.

The first argument is the `EntitySchemaBuilder` instance, which you can use to get _already generated_ types.

::: warning
Note that you can only use types here that have been generated by the schema builder!
This means that types from schema extensions are **not available** here.
:::

```php
public function getInterfaceExtender() {
  return [
    'Node' => [
      function (EntitySchemaBuilder $builder, array &$fields) {
        $fields['menuLink'] = [
          'type' => fn () => $builder->getType('MenuLinkContent'),
          'description' => 'The primary menu link of the node.',
        ];
      },
    ],
  ];
}
```

::: warning
You **must** wrap access to the `getType()` method in a closure, because the type may not exist at that point.
:::

### Full example

Checkout `MediaExtension.php` for a full example:

#### src/Plugin/GraphQL/SchemaExtension/MediaExtension.php

<<< @/../src/Plugin/GraphQL/SchemaExtension/MediaExtension.php
